import { Color, DefaultProps, PickingInfo } from '@deck.gl/core/typed';
import { Palette } from 'cpt2js';

declare enum UnitSystem {
    METRIC = "METRIC",
    IMPERIAL = "IMPERIAL",
    NAUTICAL = "NAUTICAL"
}

interface UnitFormat {
    system: UnitSystem;
    unit: string;
    scale?: number;
    offset?: number;
    decimals?: number;
}

type TextFormatFunction = (value: number, unitFormat?: UnitFormat) => string;
declare const DEFAULT_LINE_WIDTH: number;
declare const DEFAULT_LINE_COLOR: Color;
declare const DEFAULT_TEXT_FONT_FAMILY: string;
declare const DEFAULT_TEXT_SIZE: number;
declare const DEFAULT_TEXT_COLOR: Color;
declare const DEFAULT_TEXT_OUTLINE_WIDTH: number;
declare const DEFAULT_TEXT_OUTLINE_COLOR: Color;
declare const DEFAULT_TEXT_FORMAT_FUNCTION: TextFormatFunction;
declare const DEFAULT_ICON_SIZE: number;
declare const DEFAULT_ICON_COLOR: Color;
declare function ensureDefaultProps<PropsT extends {}>(props: PropsT, defaultProps: DefaultProps<PropsT>): PropsT;

interface AnimationConfig {
    onUpdate: () => void;
    fps?: number;
}
declare class Animation {
    #private;
    constructor(config: AnimationConfig);
    getConfig(): AnimationConfig;
    setConfig(config: AnimationConfig): void;
    updateConfig(config: Partial<AnimationConfig>): void;
    get running(): boolean;
    toggle(running?: boolean): void;
    start(): void;
    stop(): void;
    step(): void;
}

type DatetimeISOString = string;
type DatetimeISOStringRange = [start: DatetimeISOString, end: DatetimeISOString];
type DatetimeFormatFunction = (value: DatetimeISOString) => DatetimeISOString;
declare function interpolateDatetime(start: DatetimeISOString, end: DatetimeISOString | null, weight: number): string;
declare function getDatetimeWeight(start: DatetimeISOString, end: DatetimeISOString | null, middle: DatetimeISOString): number;
declare function getClosestStartDatetime(datetimes: DatetimeISOString[], datetime: DatetimeISOString): DatetimeISOString | undefined;
declare function getClosestEndDatetime(datetimes: DatetimeISOString[], datetime: DatetimeISOString): DatetimeISOString | undefined;
declare function offsetDatetime(datetime: DatetimeISOString, hour: number): DatetimeISOString;
declare function offsetDatetimeRange(datetime: DatetimeISOString, start: number, end: number): DatetimeISOStringRange;
declare function formatDatetime(value: DatetimeISOString): string;

declare enum DirectionFormat {
    VALUE = "VALUE",
    CARDINAL = "CARDINAL",
    CARDINAL2 = "CARDINAL2",
    CARDINAL3 = "CARDINAL3"
}

declare function formatValue(value: number, unitFormat?: UnitFormat): string;
declare function formatUnit(unitFormat: UnitFormat): string;
declare function formatValueWithUnit(value: number, unitFormat: UnitFormat): string;
declare function formatDirection(direction: number, directionFormat: DirectionFormat): string;

declare enum ImageInterpolation {
    NEAREST = "NEAREST",
    LINEAR = "LINEAR",
    CUBIC = "CUBIC"
}

declare enum ImageType {
    SCALAR = "SCALAR",
    VECTOR = "VECTOR"
}

type TextureDataArray = Uint8Array | Uint8ClampedArray | Float32Array;
interface TextureData {
    data: TextureDataArray;
    width: number;
    height: number;
}
type FloatDataArray = Float32Array;
interface FloatData {
    data: FloatDataArray;
    width: number;
    height: number;
}
type LoadFunction<T> = (url: string) => Promise<T>;
type CachedLoadFunction<T> = (url: string, cache?: Map<string, T | Promise<T>> | false) => T | Promise<T>;
declare const loadTextureData: CachedLoadFunction<TextureData>;
declare const loadJson: CachedLoadFunction<any>;

type ImageUnscale = [min: number, max: number] | null;

interface RasterPointProperties {
    value: number;
    direction?: number;
}
declare function getRasterPoints(image: TextureData, image2: TextureData | null, imageSmoothing: number, imageInterpolation: ImageInterpolation, imageWeight: number, imageType: ImageType, imageUnscale: ImageUnscale, bounds: GeoJSON.BBox, positions: GeoJSON.Position[]): GeoJSON.FeatureCollection<GeoJSON.Point, RasterPointProperties>;
declare function getRasterMagnitudeData(image: TextureData, image2: TextureData | null, imageSmoothing: number, imageInterpolation: ImageInterpolation, imageWeight: number, imageType: ImageType, imageUnscale: ImageUnscale): FloatData;

declare abstract class Control<ControlConfig> {
    addTo(target: HTMLElement): void;
    prependTo(target: HTMLElement): void;
    remove(): void;
    updateConfig(config: Partial<ControlConfig>): void;
    abstract getConfig(): ControlConfig;
    abstract setConfig(config: ControlConfig): void;
    protected abstract onAdd(): HTMLElement;
    protected abstract onRemove(): void;
}

interface LegendControlConfig {
    width: number;
    ticksCount: number;
    title: string;
    unitFormat: UnitFormat;
    palette: Palette;
}
declare class LegendControl extends Control<LegendControlConfig> {
    #private;
    constructor(config?: LegendControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    getConfig(): LegendControlConfig;
    setConfig(config: LegendControlConfig): void;
}

interface TooltipControlConfig {
    unitFormat: UnitFormat;
    directionFormat?: DirectionFormat;
    followCursor?: boolean;
}
declare class TooltipControl extends Control<TooltipControlConfig> {
    #private;
    constructor(config?: TooltipControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    getConfig(): TooltipControlConfig;
    setConfig(config: TooltipControlConfig): void;
    update(rasterPointProperties: RasterPointProperties | undefined): void;
    updatePickingInfo(pickingInfo: PickingInfo & {
        raster?: RasterPointProperties;
    }): void;
}

interface TimelineControlConfig {
    width: number;
    datetimes: DatetimeISOString[];
    datetime: DatetimeISOString;
    datetimeInterpolate: boolean;
    datetimeFormatFunction?: DatetimeFormatFunction;
    onPreload?: (datetimes: DatetimeISOString[]) => Promise<void>;
    onUpdate?: (datetime: DatetimeISOString) => void;
    fps?: number;
}
declare class TimelineControl extends Control<TimelineControlConfig> {
    #private;
    constructor(config?: TimelineControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    get loading(): boolean;
    get running(): boolean;
    toggle(running?: boolean): Promise<void>;
    start(): Promise<void>;
    pause(): void;
    stop(): void;
    reset(): void;
    stepBackward(): Promise<void>;
    stepForward(): Promise<void>;
    getConfig(): TimelineControlConfig;
    setConfig(config: TimelineControlConfig): void;
}

interface AttributionControlConfig {
    attribution: string;
}
declare class AttributionControl extends Control<AttributionControlConfig> {
    #private;
    constructor(config?: AttributionControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    getConfig(): AttributionControlConfig;
    setConfig(config: AttributionControlConfig): void;
}

interface LogoControlConfig {
}
declare class LogoControl extends Control<LogoControlConfig> {
    #private;
    constructor(config?: LogoControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    getConfig(): LogoControlConfig;
    setConfig(config: LogoControlConfig): void;
}

declare enum GridStyle {
    VALUE = "VALUE",
    ARROW = "ARROW",
    WIND_BARB = "WIND_BARB"
}

declare function getRasterImage(image: TextureData, imageSmoothing: number, imageInterpolation: ImageInterpolation, imageType: ImageType, imageUnscale: ImageUnscale, palette: Palette): HTMLCanvasElement;

declare const RasterProvider: {
    getRasterImage: typeof getRasterImage;
};

interface ContourLineProperties {
    value: number;
}
declare function getContourLines(image: TextureData, image2: TextureData | null, imageSmoothing: number, imageInterpolation: ImageInterpolation, imageWeight: number, imageType: ImageType, imageUnscale: ImageUnscale, bounds: GeoJSON.BBox, interval: number): Promise<GeoJSON.FeatureCollection<GeoJSON.LineString, ContourLineProperties>>;

interface ContourLabelProperties {
    value: number;
    angle: number;
}
declare function getContourLabels(contourLines: GeoJSON.Feature<GeoJSON.LineString, ContourLineProperties>[]): GeoJSON.Feature<GeoJSON.Point, ContourLabelProperties>[];

declare const ContourProvider: {
    getContourLines: typeof getContourLines;
    getContourLabels: typeof getContourLabels;
};

declare enum HighLowType {
    LOW = "L",
    HIGH = "H"
}
interface HighLowPointProperties {
    type: HighLowType;
    value: number;
}
declare function getHighLowPoints(image: TextureData, image2: TextureData | null, imageSmoothing: number, imageInterpolation: ImageInterpolation, imageWeight: number, imageType: ImageType, imageUnscale: ImageUnscale, bounds: GeoJSON.BBox, radius: number): Promise<GeoJSON.FeatureCollection<GeoJSON.Point, HighLowPointProperties>>;

declare const HighLowProvider: {
    getHighLowPoints: typeof getHighLowPoints;
};

export { Animation, type AnimationConfig, AttributionControl, type AttributionControlConfig, type CachedLoadFunction, ContourProvider, DEFAULT_ICON_COLOR, DEFAULT_ICON_SIZE, DEFAULT_LINE_COLOR, DEFAULT_LINE_WIDTH, DEFAULT_TEXT_COLOR, DEFAULT_TEXT_FONT_FAMILY, DEFAULT_TEXT_FORMAT_FUNCTION, DEFAULT_TEXT_OUTLINE_COLOR, DEFAULT_TEXT_OUTLINE_WIDTH, DEFAULT_TEXT_SIZE, type DatetimeFormatFunction, type DatetimeISOString, type DatetimeISOStringRange, DirectionFormat, type FloatData, type FloatDataArray, GridStyle, HighLowProvider, ImageInterpolation, ImageType, LegendControl, type LegendControlConfig, type LoadFunction, LogoControl, type LogoControlConfig, type RasterPointProperties, RasterProvider, type TextFormatFunction, type TextureData, type TextureDataArray, TimelineControl, type TimelineControlConfig, TooltipControl, type TooltipControlConfig, UnitSystem, ensureDefaultProps, formatDatetime, formatDirection, formatUnit, formatValue, formatValueWithUnit, getClosestEndDatetime, getClosestStartDatetime, getDatetimeWeight, getRasterMagnitudeData, getRasterPoints, interpolateDatetime, loadJson, loadTextureData, offsetDatetime, offsetDatetimeRange };
